"""
ÊµãËØïÁî®‰æãÊô∫ËÉΩ‰ΩìÁºñÊéíÊúçÂä° - Áªü‰∏ÄÁâàÊú¨
ÂçèË∞ÉÊµãËØïÁî®‰æãÁõ∏ÂÖ≥Êô∫ËÉΩ‰ΩìÁöÑÊâßË°åÊµÅÁ®ãÔºåÈõÜÊàêÊô∫ËÉΩ‰ΩìÁÆ°ÁêÜÂô®ÂäüËÉΩ
Êèê‰æõÂÆåÊï¥ÁöÑ‰∏öÂä°ÊµÅÁ®ãÁºñÊéí„ÄÅÊÄßËÉΩÁõëÊéßÂíåÈÖçÁΩÆÁÆ°ÁêÜ
"""
from typing import Dict, Any, List, Optional
from datetime import datetime
from loguru import logger
from autogen_core import SingleThreadedAgentRuntime, TopicId, TypeSubscription

# ÂØºÂÖ•Êô∫ËÉΩ‰ΩìÂ∑•ÂéÇÂíåÁÆ°ÁêÜÂô®
from app.agents.factory import agent_factory
from app.core.types import TopicTypes, AgentTypes
from app.core.agents.collector import StreamResponseCollector
from app.agents.database.session_status_agent import SessionStatusAgent, SessionStatusManager
# ÂØºÂÖ•Ê∂àÊÅØÁ±ªÂûã
from app.core.messages.test_case import (
    DocumentParseRequest, ImageAnalysisRequest, ApiSpecParseRequest,
    DatabaseSchemaParseRequest, VideoAnalysisRequest,
    MindMapGenerationRequest, ExcelExportRequest, BatchProcessRequest,
    DirectRequirementRequest, RequirementAnalysisRequest
)


class TestCaseAgentOrchestrator:
    """
    ÊµãËØïÁî®‰æãÊô∫ËÉΩ‰ΩìÁºñÊéíÂô® - Áªü‰∏ÄÁâàÊú¨

    ÈõÜÊàê‰∫ÜÊô∫ËÉΩ‰ΩìÁÆ°ÁêÜÂô®ÁöÑÂäüËÉΩÔºåÊèê‰æõÔºö
    1. Êô∫ËÉΩ‰ΩìÁîüÂëΩÂë®ÊúüÁÆ°ÁêÜ
    2. ÊÄßËÉΩÁõëÊéßÂíåÂÅ•Â∫∑Ê£ÄÊü•
    3. ÈÖçÁΩÆÁÆ°ÁêÜ
    4. Â∑•‰ΩúÊµÅÁºñÊéí
    5. ÈîôËØØÊÅ¢Â§çÂíåÈáçËØï

    Ë¥üË¥£ÂçèË∞ÉÂêÑÁßçÊµãËØïÁî®‰æãÁõ∏ÂÖ≥Êô∫ËÉΩ‰ΩìÁöÑÂ∑•‰ΩúÊµÅÁ®ãÔºö
    - ÊñáÊ°£Ëß£ÊûêÊô∫ËÉΩ‰Ωì
    - ÂõæÁâáÂàÜÊûêÊô∫ËÉΩ‰Ωì
    - APIËßÑËåÉËß£ÊûêÊô∫ËÉΩ‰Ωì
    - Êï∞ÊçÆÂ∫ìSchemaËß£ÊûêÊô∫ËÉΩ‰Ωì
    - ÂΩïÂ±èÂàÜÊûêÊô∫ËÉΩ‰Ωì
    - ÊµãËØïÁî®‰æãÁîüÊàêÊô∫ËÉΩ‰Ωì
    - ÊÄùÁª¥ÂØºÂõæÁîüÊàêÊô∫ËÉΩ‰Ωì
    - ExcelÂØºÂá∫Êô∫ËÉΩ‰Ωì
    """

    def __init__(self, collector: Optional[StreamResponseCollector] = None):
        """
        ÂàùÂßãÂåñÊµãËØïÁî®‰æãÊô∫ËÉΩ‰ΩìÁºñÊéíÂô®

        Args:
            collector: ÂèØÈÄâÁöÑStreamResponseCollectorÁî®‰∫éÊçïËé∑Êô∫ËÉΩ‰ΩìÂìçÂ∫î
        """
        self.response_collector = collector
        self.runtime: Optional[SingleThreadedAgentRuntime] = None
        self.agent_factory = agent_factory
        self.active_sessions: Dict[str, Dict[str, Any]] = {}

        # ÁºñÊéíÂô®ÊÄßËÉΩÊåáÊ†á
        self.orchestrator_metrics = {
            "total_workflows": 0,
            "successful_workflows": 0,
            "failed_workflows": 0,
            "active_sessions": 0
        }
        logger.info("ÊµãËØïÁî®‰æãÊô∫ËÉΩ‰ΩìÁºñÊéíÂô®ÂàùÂßãÂåñÂÆåÊàê")

    async def initialize(self, **agent_kwargs) -> None:
        """
        ÂàùÂßãÂåñÁºñÊéíÂô®ÂíåÊô∫ËÉΩ‰ΩìÁÆ°ÁêÜÂô®

        Args:
            **agent_kwargs: Êô∫ËÉΩ‰ΩìÂàùÂßãÂåñÂèÇÊï∞
        """
        try:
            logger.info("üöÄ ÂàùÂßãÂåñÊµãËØïÁî®‰æãÊô∫ËÉΩ‰ΩìÁºñÊéíÂô®...")

            if self.runtime is None:
                # ÂàõÂª∫ËøêË°åÊó∂
                self.runtime = SingleThreadedAgentRuntime()
                await self._register_test_case_agents()
                # ËÆæÁΩÆÂìçÂ∫îÊî∂ÈõÜÂô®
                if self.response_collector:
                    await self.agent_factory.register_stream_collector(
                        runtime=self.runtime,
                        collector=self.response_collector
                    )

                # ÂêØÂä®ËøêË°åÊó∂
                self.runtime.start()

                logger.info("‚úÖ ÊµãËØïÁî®‰æãÊô∫ËÉΩ‰ΩìÁºñÊéíÂô®ÂàùÂßãÂåñÂÆåÊàê")

        except Exception as e:
            logger.error(f"‚ùå ÊµãËØïÁî®‰æãÊô∫ËÉΩ‰ΩìÁºñÊéíÂô®ÂàùÂßãÂåñÂ§±Ë¥•: {str(e)}")
            raise

    async def _initialize_runtime(self, session_id: str) -> None:
        """
        ÂàùÂßãÂåñÊô∫ËÉΩ‰ΩìËøêË°åÊó∂ÁéØÂ¢ÉÔºàÂÖºÂÆπÊÄßÊñπÊ≥ïÔºâ

        Args:
            session_id: ‰ºöËØùÊ†áËØÜÁ¨¶
        """
        try:
            # Â¶ÇÊûúËøòÊ≤°ÊúâÂàùÂßãÂåñÔºåÂàôËøõË°åÂàùÂßãÂåñ
            if self.runtime is None:
                await self.initialize()

            # ËÆ∞ÂΩï‰ºöËØù
            self.active_sessions[session_id] = {
                "created_at": datetime.now().isoformat(),
                "status": "active"
            }

            logger.info(f"‰ºöËØùÂ∑≤ËÆ∞ÂΩï: {session_id}")

        except Exception as e:
            logger.error(f"ÂàùÂßãÂåñÊô∫ËÉΩ‰ΩìËøêË°åÊó∂Â§±Ë¥•: {session_id}, ÈîôËØØ: {str(e)}")
            raise
    async def _cleanup_runtime(self, session_id: Optional[str] = None) -> None:
        """
        Ê∏ÖÁêÜËøêË°åÊó∂ËµÑÊ∫ê

        Ê∏ÖÁêÜÊµÅÁ®ã:
        1. Âêë‰ºöËØùÁä∂ÊÄÅÊõ¥Êñ∞Êô∫ËÉΩ‰ΩìÂèëÈÄÅÂ∑≤ÂÆåÊàêÁöÑÊ∂àÊÅØÔºàÂ¶ÇÊûúÊèê‰æõ‰∫Üsession_idÔºâ
        2. ÂÅúÊ≠¢ËøêË°åÊó∂ÂΩìÁ©∫Èó≤Êó∂ (Á≠âÂæÖÊâÄÊúâÊô∫ËÉΩ‰ΩìÂÆåÊàêÂΩìÂâç‰ªªÂä°)
        3. ÂÖ≥Èó≠ËøêË°åÊó∂Âπ∂ÈáäÊîæËµÑÊ∫ê
        4. Ê∏ÖÈô§Êô∫ËÉΩ‰ΩìÂ∑•ÂéÇÊ≥®ÂÜåËÆ∞ÂΩï
        5. ÈáçÁΩÆÂìçÂ∫îÊî∂ÈõÜÂô®‰∏∫None
        6. ËÆæÁΩÆËøêË°åÊó∂‰∏∫None

        ËøôÁ°Æ‰øùÊô∫ËÉΩ‰ΩìÂ∑•‰ΩúÊµÅÂÆåÊàêÂêéÁöÑÈÄÇÂΩìËµÑÊ∫êÊ∏ÖÁêÜ„ÄÇ

        Args:
            session_id: ÂèØÈÄâÁöÑ‰ºöËØùIDÔºåÂ¶ÇÊûúÊèê‰æõÂàô‰ºöÊ†áËÆ∞ËØ•‰ºöËØù‰∏∫Â∑≤ÂÆåÊàê
        """
        try:
            if self.runtime:
                await self.runtime.stop_when_idle()
                await self.runtime.close()
                self.runtime = None

            # Â¶ÇÊûúÊèê‰æõ‰∫Ü‰ºöËØùIDÔºåÂêë‰ºöËØùÁä∂ÊÄÅÊõ¥Êñ∞Êô∫ËÉΩ‰ΩìÂèëÈÄÅÂ∑≤ÂÆåÊàêÁöÑÊ∂àÊÅØ
            if session_id:
                logger.info(f"Ê†áËÆ∞‰ºöËØù‰∏∫Â∑≤ÂÆåÊàê: {session_id}")
                # ÂàùÂßãÂåñ‰ºöËØùÁä∂ÊÄÅÁÆ°ÁêÜÂô®
                session_status_manager = SessionStatusManager()

                await session_status_manager.mark_session_completed(
                    session_id=session_id,
                    processing_time=None,  # ÂèØ‰ª•Âú®ËøôÈáåËÆ°ÁÆóÂÆûÈôÖÂ§ÑÁêÜÊó∂Èó¥
                    generated_count=None  # ÂèØ‰ª•Âú®ËøôÈáåËé∑ÂèñÁîüÊàêÁöÑÊµãËØïÁî®‰æãÊï∞Èáè
                )

            logger.debug("ËøêË°åÊó∂Ê∏ÖÁêÜÊàêÂäüÂÆåÊàê")

        except Exception as e:
            logger.error(f"ËøêË°åÊó∂Ê∏ÖÁêÜÂ§±Ë¥•: {str(e)}")
    async def _register_test_case_agents(self) -> None:
        """Ê≥®ÂÜåÊâÄÊúâÊµãËØïÁî®‰æãÁõ∏ÂÖ≥Êô∫ËÉΩ‰Ωì"""
        try:
            # Ê≥®ÂÜåÊñáÊ°£Ëß£ÊûêÊô∫ËÉΩ‰Ωì
            await self.agent_factory.register_agent_to_runtime(
                self.runtime,
                AgentTypes.DOCUMENT_PARSER.value,
                TopicTypes.DOCUMENT_PARSER.value,
            )

            # Ê≥®ÂÜåÂõæÁâáÂàÜÊûêÊô∫ËÉΩ‰Ωì
            await self.agent_factory.register_agent_to_runtime(
                self.runtime,
                AgentTypes.IMAGE_ANALYZER.value,
                TopicTypes.IMAGE_ANALYZER.value,
            )

            # Ê≥®ÂÜåAPIËßÑËåÉËß£ÊûêÊô∫ËÉΩ‰Ωì
            await self.agent_factory.register_agent_to_runtime(
                self.runtime,
                AgentTypes.API_SPEC_PARSER.value,
                TopicTypes.API_SPEC_PARSER.value,
            )

            # Ê≥®ÂÜåÊï∞ÊçÆÂ∫ìSchemaËß£ÊûêÊô∫ËÉΩ‰Ωì
            await self.agent_factory.register_agent_to_runtime(
                self.runtime,
                AgentTypes.DATABASE_SCHEMA_PARSER.value,
                TopicTypes.DATABASE_SCHEMA_PARSER.value,
            )

            # Ê≥®ÂÜåÂΩïÂ±èÂàÜÊûêÊô∫ËÉΩ‰Ωì
            await self.agent_factory.register_agent_to_runtime(
                self.runtime,
                AgentTypes.VIDEO_ANALYZER.value,
                TopicTypes.VIDEO_ANALYZER.value,
            )

            # Ê≥®ÂÜåÈúÄÊ±ÇËß£ÊûêÊô∫ËÉΩ‰Ωì
            await self.agent_factory.register_agent_to_runtime(
                self.runtime,
                AgentTypes.REQUIREMENT_ANALYZER.value,
                TopicTypes.REQUIREMENT_ANALYZER.value,
            )

            # Ê≥®ÂÜåÊµãËØïÁÇπÊèêÂèñÊô∫ËÉΩ‰Ωì
            await self.agent_factory.register_agent_to_runtime(
                self.runtime,
                AgentTypes.TEST_POINT_EXTRACTOR.value,
                TopicTypes.TEST_POINT_EXTRACTOR.value,
            )

            # Ê≥®ÂÜåÊµãËØïÁî®‰æãÁîüÊàêÊô∫ËÉΩ‰Ωì
            await self.agent_factory.register_agent_to_runtime(
                self.runtime,
                AgentTypes.TEST_CASE_GENERATOR.value,
                TopicTypes.TEST_CASE_GENERATOR.value,
            )

            # Ê≥®ÂÜåRAGÁü•ËØÜÂ∫ìÊ£ÄÁ¥¢Êô∫ËÉΩ‰Ωì
            await self.agent_factory.register_agent_to_runtime(
                self.runtime,
                AgentTypes.RAG_RETRIEVAL.value,
                TopicTypes.RAG_RETRIEVAL.value,
            )

            # Ê≥®ÂÜåÊÄùÁª¥ÂØºÂõæÁîüÊàêÊô∫ËÉΩ‰Ωì
            await self.agent_factory.register_agent_to_runtime(
                self.runtime,
                AgentTypes.MIND_MAP_GENERATOR.value,
                TopicTypes.MIND_MAP_GENERATOR.value,
            )

            # Ê≥®ÂÜåExcelÂØºÂá∫Êô∫ËÉΩ‰Ωì
            await self.agent_factory.register_agent_to_runtime(
                self.runtime,
                AgentTypes.EXCEL_EXPORTER.value,
                TopicTypes.EXCEL_EXPORTER.value,
            )

            # Ê≥®ÂÜåÊï∞ÊçÆ‰øùÂ≠òÊô∫ËÉΩ‰Ωì
            await self.agent_factory.register_agent_to_runtime(
                self.runtime,
                AgentTypes.TEST_CASE_SAVER.value,
                TopicTypes.TEST_CASE_SAVER.value,
            )

            # Ê≥®ÂÜåÈúÄÊ±Ç‰øùÂ≠òÊô∫ËÉΩ‰Ωì
            await self.agent_factory.register_agent_to_runtime(
                self.runtime,
                AgentTypes.REQUIREMENT_SAVER.value,
                TopicTypes.REQUIREMENT_SAVER.value,
            )

            # Ê≥®ÂÜå‰ºöËØùÁä∂ÊÄÅÊô∫ËÉΩ‰Ωì
            await self.agent_factory.register_agent_to_runtime(
                self.runtime,
                AgentTypes.SESSION_STATUS.value,
                TopicTypes.SESSION_STATUS.value,
            )

            logger.info("ÊâÄÊúâÊµãËØïÁî®‰æãÊô∫ËÉΩ‰ΩìÊ≥®ÂÜåÂÆåÊàê")

        except Exception as e:
            logger.error(f"Ê≥®ÂÜåÊô∫ËÉΩ‰ΩìÂ§±Ë¥•: {str(e)}")
            raise

    # ==================== Â∑•‰ΩúÊµÅÁÆ°ÁêÜÊñπÊ≥ï ====================

    async def _start_workflow(self, workflow_type: str, session_id: str) -> str:
        """ÂºÄÂßãÂ∑•‰ΩúÊµÅ"""
        workflow_id = f"{workflow_type}_{session_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}"

        self.active_sessions[workflow_id] = {
            "workflow_id": workflow_id,
            "workflow_type": workflow_type,
            "session_id": session_id,
            "status": "running",
            "started_at": datetime.now(),
            "completed_at": None,
            "success": None,
            "error": None
        }

        self.orchestrator_metrics["total_workflows"] += 1
        return workflow_id

    async def _complete_workflow(self, workflow_id: str, success: bool, error: str = None):
        """ÂÆåÊàêÂ∑•‰ΩúÊµÅ"""
        if workflow_id in self.active_sessions:
            self.active_sessions[workflow_id].update({
                "status": "completed" if success else "failed",
                "completed_at": datetime.now(),
                "success": success,
                "error": error
            })

            if success:
                self.orchestrator_metrics["successful_workflows"] += 1
            else:
                self.orchestrator_metrics["failed_workflows"] += 1

    # ==================== Â∑•‰ΩúÊµÅÊñπÊ≥ï ====================

    async def parse_document(self, request: DocumentParseRequest) -> str:
        """
        Ëß£ÊûêÊñáÊ°£Âπ∂ÁîüÊàêÊµãËØïÁî®‰æã

        Êô∫ËÉΩ‰ΩìÊ∂àÊÅØÊµÅ:
        1. ÂèëÈÄÅ DocumentParseRequest ‚Üí DOCUMENT_PARSER Êô∫ËÉΩ‰Ωì
        2. DocumentParserAgent Ëß£ÊûêÊñáÊ°£ÂÜÖÂÆπ
        3. DocumentParserAgent ÂèëÈÄÅ TestCaseGenerationRequest ‚Üí TEST_CASE_GENERATOR Êô∫ËÉΩ‰Ωì
        4. TestCaseGeneratorAgent ÁîüÊàêÂπ∂‰øùÂ≠òÊµãËØïÁî®‰æã
        5. TestCaseGeneratorAgent ÂèëÈÄÅ MindMapGenerationRequest ‚Üí MIND_MAP_GENERATOR Êô∫ËÉΩ‰Ωì
        6. MindMapGeneratorAgent ÁîüÊàêÊÄùÁª¥ÂØºÂõæ

        Args:
            request: ÊñáÊ°£Ëß£ÊûêËØ∑Ê±Ç

        Returns:
            str: Â∑•‰ΩúÊµÅID
        """
        workflow_id = await self._start_workflow("document_parse", request.session_id)

        try:
            logger.info(f"ÂºÄÂßãÊñáÊ°£Ëß£ÊûêÂ∑•‰ΩúÊµÅ: {request.session_id}")

            # ÂàùÂßãÂåñËøêË°åÊó∂
            await self._initialize_runtime(request.session_id)

            # ÂèëÈÄÅÂà∞ÊñáÊ°£Ëß£ÊûêÊô∫ËÉΩ‰Ωì
            await self.runtime.publish_message(
                request,
                topic_id=TopicId(type=TopicTypes.DOCUMENT_PARSER.value, source="orchestrator")
            )

            await self._complete_workflow(workflow_id, True)
            logger.info(f"ÊñáÊ°£Ëß£ÊûêÂ∑•‰ΩúÊµÅÂêØÂä®ÂÆåÊàê: {request.session_id}")
            return workflow_id

        except Exception as e:
            await self._complete_workflow(workflow_id, False, str(e))
            logger.error(f"ÊñáÊ°£Ëß£ÊûêÂ∑•‰ΩúÊµÅÂ§±Ë¥•: {request.session_id}, ÈîôËØØ: {str(e)}")
            raise
        finally:
            await self._cleanup_runtime(request.session_id)

    async def analyze_image(self, request: ImageAnalysisRequest) -> None:
        """
        ÂàÜÊûêÂõæÁâáÂπ∂ÁîüÊàêÊµãËØïÁî®‰æã
        
        Êô∫ËÉΩ‰ΩìÊ∂àÊÅØÊµÅ:
        1. ÂèëÈÄÅ ImageAnalysisRequest ‚Üí IMAGE_ANALYZER Êô∫ËÉΩ‰Ωì
        2. ImageAnalyzerAgent ÂàÜÊûêÂõæÁâáÂÜÖÂÆπ
        3. ImageAnalyzerAgent ÂèëÈÄÅ TestCaseGenerationRequest ‚Üí TEST_CASE_GENERATOR Êô∫ËÉΩ‰Ωì
        4. TestCaseGeneratorAgent ÁîüÊàêÂπ∂‰øùÂ≠òÊµãËØïÁî®‰æã
        5. TestCaseGeneratorAgent ÂèëÈÄÅ MindMapGenerationRequest ‚Üí MIND_MAP_GENERATOR Êô∫ËÉΩ‰Ωì
        6. MindMapGeneratorAgent ÁîüÊàêÊÄùÁª¥ÂØºÂõæ
        
        Args:
            request: ÂõæÁâáÂàÜÊûêËØ∑Ê±Ç
        """
        try:
            logger.info(f"ÂºÄÂßãÂõæÁâáÂàÜÊûêÂ∑•‰ΩúÊµÅ: {request.session_id}")
            
            # ÂàùÂßãÂåñËøêË°åÊó∂
            await self._initialize_runtime(request.session_id)
            
            # ÂèëÈÄÅÂà∞ÂõæÁâáÂàÜÊûêÊô∫ËÉΩ‰Ωì
            await self.runtime.publish_message(
                request,
                topic_id=TopicId(type=TopicTypes.IMAGE_ANALYZER.value, source="user")
            )
            
            logger.info(f"ÂõæÁâáÂàÜÊûêÂ∑•‰ΩúÊµÅÂêØÂä®ÂÆåÊàê: {request.session_id}")
            
        except Exception as e:
            logger.error(f"ÂõæÁâáÂàÜÊûêÂ∑•‰ΩúÊµÅÂ§±Ë¥•: {request.session_id}, ÈîôËØØ: {str(e)}")
            raise
        finally:
            await self._cleanup_runtime(request.session_id)

    async def parse_api_spec(self, request: ApiSpecParseRequest) -> None:
        """
        Ëß£ÊûêAPIËßÑËåÉÂπ∂ÁîüÊàêÊµãËØïÁî®‰æã
        
        Êô∫ËÉΩ‰ΩìÊ∂àÊÅØÊµÅ:
        1. ÂèëÈÄÅ ApiSpecParseRequest ‚Üí API_SPEC_PARSER Êô∫ËÉΩ‰Ωì
        2. ApiSpecParserAgent Ëß£ÊûêAPIËßÑËåÉ
        3. ApiSpecParserAgent ÂèëÈÄÅ TestCaseGenerationRequest ‚Üí TEST_CASE_GENERATOR Êô∫ËÉΩ‰Ωì
        4. TestCaseGeneratorAgent ÁîüÊàêÂπ∂‰øùÂ≠òÊµãËØïÁî®‰æã
        5. TestCaseGeneratorAgent ÂèëÈÄÅ MindMapGenerationRequest ‚Üí MIND_MAP_GENERATOR Êô∫ËÉΩ‰Ωì
        6. MindMapGeneratorAgent ÁîüÊàêÊÄùÁª¥ÂØºÂõæ
        
        Args:
            request: APIËßÑËåÉËß£ÊûêËØ∑Ê±Ç
        """
        try:
            logger.info(f"ÂºÄÂßãAPIËßÑËåÉËß£ÊûêÂ∑•‰ΩúÊµÅ: {request.session_id}")
            
            # ÂàùÂßãÂåñËøêË°åÊó∂
            await self._initialize_runtime(request.session_id)
            
            # ÂèëÈÄÅÂà∞APIËßÑËåÉËß£ÊûêÊô∫ËÉΩ‰Ωì
            await self.runtime.publish_message(
                request,
                topic_id=TopicId(type=TopicTypes.API_SPEC_PARSER.value, source="user")
            )
            
            logger.info(f"APIËßÑËåÉËß£ÊûêÂ∑•‰ΩúÊµÅÂêØÂä®ÂÆåÊàê: {request.session_id}")
            
        except Exception as e:
            logger.error(f"APIËßÑËåÉËß£ÊûêÂ∑•‰ΩúÊµÅÂ§±Ë¥•: {request.session_id}, ÈîôËØØ: {str(e)}")
            raise
        finally:
            await self._cleanup_runtime(request.session_id)

    async def parse_database_schema(self, request: DatabaseSchemaParseRequest) -> None:
        """
        Ëß£ÊûêÊï∞ÊçÆÂ∫ìSchemaÂπ∂ÁîüÊàêÊµãËØïÁî®‰æã
        
        Êô∫ËÉΩ‰ΩìÊ∂àÊÅØÊµÅ:
        1. ÂèëÈÄÅ DatabaseSchemaParseRequest ‚Üí DATABASE_SCHEMA_PARSER Êô∫ËÉΩ‰Ωì
        2. DatabaseSchemaParserAgent Ëß£ÊûêÊï∞ÊçÆÂ∫ìSchema
        3. DatabaseSchemaParserAgent ÂèëÈÄÅ TestCaseGenerationRequest ‚Üí TEST_CASE_GENERATOR Êô∫ËÉΩ‰Ωì
        4. TestCaseGeneratorAgent ÁîüÊàêÂπ∂‰øùÂ≠òÊµãËØïÁî®‰æã
        5. TestCaseGeneratorAgent ÂèëÈÄÅ MindMapGenerationRequest ‚Üí MIND_MAP_GENERATOR Êô∫ËÉΩ‰Ωì
        6. MindMapGeneratorAgent ÁîüÊàêÊÄùÁª¥ÂØºÂõæ
        
        Args:
            request: Êï∞ÊçÆÂ∫ìSchemaËß£ÊûêËØ∑Ê±Ç
        """
        try:
            logger.info(f"ÂºÄÂßãÊï∞ÊçÆÂ∫ìSchemaËß£ÊûêÂ∑•‰ΩúÊµÅ: {request.session_id}")
            
            # ÂàùÂßãÂåñËøêË°åÊó∂
            await self._initialize_runtime(request.session_id)
            
            # ÂèëÈÄÅÂà∞Êï∞ÊçÆÂ∫ìSchemaËß£ÊûêÊô∫ËÉΩ‰Ωì
            await self.runtime.publish_message(
                request,
                topic_id=TopicId(type=TopicTypes.DATABASE_SCHEMA_PARSER.value, source="user")
            )
            
            logger.info(f"Êï∞ÊçÆÂ∫ìSchemaËß£ÊûêÂ∑•‰ΩúÊµÅÂêØÂä®ÂÆåÊàê: {request.session_id}")
            
        except Exception as e:
            logger.error(f"Êï∞ÊçÆÂ∫ìSchemaËß£ÊûêÂ∑•‰ΩúÊµÅÂ§±Ë¥•: {request.session_id}, ÈîôËØØ: {str(e)}")
            raise
        finally:
            await self._cleanup_runtime(request.session_id)

    async def analyze_video(self, request: VideoAnalysisRequest) -> None:
        """
        ÂàÜÊûêÂΩïÂ±èËßÜÈ¢ëÂπ∂ÁîüÊàêÊµãËØïÁî®‰æã
        
        Êô∫ËÉΩ‰ΩìÊ∂àÊÅØÊµÅ:
        1. ÂèëÈÄÅ VideoAnalysisRequest ‚Üí VIDEO_ANALYZER Êô∫ËÉΩ‰Ωì
        2. VideoAnalyzerAgent ÂàÜÊûêÂΩïÂ±èËßÜÈ¢ë
        3. VideoAnalyzerAgent ÂèëÈÄÅ TestCaseGenerationRequest ‚Üí TEST_CASE_GENERATOR Êô∫ËÉΩ‰Ωì
        4. TestCaseGeneratorAgent ÁîüÊàêÂπ∂‰øùÂ≠òÊµãËØïÁî®‰æã
        5. TestCaseGeneratorAgent ÂèëÈÄÅ MindMapGenerationRequest ‚Üí MIND_MAP_GENERATOR Êô∫ËÉΩ‰Ωì
        6. MindMapGeneratorAgent ÁîüÊàêÊÄùÁª¥ÂØºÂõæ
        
        Args:
            request: ÂΩïÂ±èÂàÜÊûêËØ∑Ê±Ç
        """
        try:
            logger.info(f"ÂºÄÂßãÂΩïÂ±èÂàÜÊûêÂ∑•‰ΩúÊµÅ: {request.session_id}")
            
            # ÂàùÂßãÂåñËøêË°åÊó∂
            await self._initialize_runtime(request.session_id)
            
            # ÂèëÈÄÅÂà∞ÂΩïÂ±èÂàÜÊûêÊô∫ËÉΩ‰Ωì
            await self.runtime.publish_message(
                request,
                topic_id=TopicId(type=TopicTypes.VIDEO_ANALYZER.value, source="user")
            )
            
            logger.info(f"ÂΩïÂ±èÂàÜÊûêÂ∑•‰ΩúÊµÅÂêØÂä®ÂÆåÊàê: {request.session_id}")

        except Exception as e:
            logger.error(f"ÂΩïÂ±èÂàÜÊûêÂ∑•‰ΩúÊµÅÂ§±Ë¥•: {request.session_id}, ÈîôËØØ: {str(e)}")
            raise

    async def analyze_requirement(self, request: RequirementAnalysisRequest) -> None:
        """
        ÂàÜÊûêÈúÄÊ±ÇÂÜÖÂÆπÂπ∂ÁîüÊàêÊµãËØïÁî®‰æã

        Êô∫ËÉΩ‰ΩìÊ∂àÊÅØÊµÅ:
        1. ÂèëÈÄÅ RequirementAnalysisRequest ‚Üí REQUIREMENT_ANALYZER Êô∫ËÉΩ‰Ωì
        2. RequirementAnalysisAgent ËøõË°å‰ºÅ‰∏öÁ∫ßÈúÄÊ±ÇËß£Êûê
        3. RequirementAnalysisAgent ÂèëÈÄÅ TestCaseGenerationRequest ‚Üí TEST_CASE_GENERATOR Êô∫ËÉΩ‰Ωì
        4. TestCaseGeneratorAgent ÁîüÊàêÂπ∂‰øùÂ≠òÊµãËØïÁî®‰æã
        5. TestCaseGeneratorAgent ÂèëÈÄÅ MindMapGenerationRequest ‚Üí MIND_MAP_GENERATOR Êô∫ËÉΩ‰Ωì
        6. MindMapGeneratorAgent ÁîüÊàêÊÄùÁª¥ÂØºÂõæ

        Args:
            request: ÈúÄÊ±ÇËß£ÊûêËØ∑Ê±Ç
        """
        try:
            logger.info(f"ÂºÄÂßãÈúÄÊ±ÇËß£ÊûêÂ∑•‰ΩúÊµÅ: {request.session_id}")

            # ÂàùÂßãÂåñËøêË°åÊó∂
            await self._initialize_runtime(request.session_id)

            # ÂèëÈÄÅÂà∞ÈúÄÊ±ÇËß£ÊûêÊô∫ËÉΩ‰Ωì
            await self.runtime.publish_message(
                request,
                topic_id=TopicId(type=TopicTypes.REQUIREMENT_ANALYZER.value, source="user")
            )

            logger.info(f"ÈúÄÊ±ÇËß£ÊûêÂ∑•‰ΩúÊµÅÂêØÂä®ÂÆåÊàê: {request.session_id}")

        except Exception as e:
            logger.error(f"ÈúÄÊ±ÇËß£ÊûêÂ∑•‰ΩúÊµÅÂêØÂä®Â§±Ë¥•: {str(e)}")
            raise
        finally:
            await self._cleanup_runtime(request.session_id)

    async def process_direct_requirement(self, request) -> None:
        """
        Â§ÑÁêÜÁõ¥Êé•ÈúÄÊ±ÇËæìÂÖ•

        Êô∫ËÉΩ‰ΩìÊ∂àÊÅØÊµÅ:
        1. Áõ¥Êé•ÂàõÂª∫ TestCaseGenerationRequest
        2. ÂèëÈÄÅÂà∞ TEST_CASE_GENERATOR Êô∫ËÉΩ‰Ωì
        3. TestCaseGeneratorAgent ÁîüÊàêÂπ∂‰øùÂ≠òÊµãËØïÁî®‰æã
        4. TestCaseGeneratorAgent ÂèëÈÄÅ MindMapGenerationRequest ‚Üí MIND_MAP_GENERATOR Êô∫ËÉΩ‰Ωì
        5. MindMapGeneratorAgent ÁîüÊàêÊÄùÁª¥ÂØºÂõæ

        Args:
            request: Áõ¥Êé•ÈúÄÊ±ÇËØ∑Ê±Ç
        """
        try:
            logger.info(f"ÂºÄÂßãÁõ¥Êé•ÈúÄÊ±ÇÂ§ÑÁêÜÂ∑•‰ΩúÊµÅ: {request.session_id}")

            # ÂàùÂßãÂåñËøêË°åÊó∂
            await self._initialize_runtime(request.session_id)

            # ÂèëÈÄÅÂà∞ÈúÄÊ±ÇÂàÜÊûêÊô∫ËÉΩ‰ΩìÔºå‰ΩøÁî®Êñ∞ÁöÑÊµãËØïÁÇπÊèêÂèñÊµÅÁ®ã
            requirement_analysis_request = RequirementAnalysisRequest(
                session_id=request.session_id,
                requirement_content=request.requirement_text,
                source_type="direct_requirement",
                source_data={
                    "requirement_text": request.requirement_text,
                    "requirement_title": getattr(request, 'requirement_title', None),
                    "analysis_target": getattr(request, 'analysis_target', 'ÁîüÊàêÊµãËØïÁî®‰æã'),
                    "input_method": "direct"
                },
                analysis_config={
                    "enable_detailed_analysis": True,
                    "extract_business_rules": True,
                    "identify_stakeholders": True,
                    "analyze_dependencies": True
                }
            )

            # ÂèëÈÄÅÂà∞ÈúÄÊ±ÇÂàÜÊûêÊô∫ËÉΩ‰Ωì
            await self.runtime.publish_message(
                requirement_analysis_request,
                topic_id=TopicId(type=TopicTypes.REQUIREMENT_ANALYZER.value, source="user")
            )

            logger.info(f"Áõ¥Êé•ÈúÄÊ±ÇÂ§ÑÁêÜÂ∑•‰ΩúÊµÅÂêØÂä®ÂÆåÊàê: {request.session_id}")

        except Exception as e:
            logger.error(f"Áõ¥Êé•ÈúÄÊ±ÇÂ§ÑÁêÜÂ∑•‰ΩúÊµÅÂ§±Ë¥•: {request.session_id}, ÈîôËØØ: {str(e)}")
            raise
        finally:
            await self._cleanup_runtime(request.session_id)

    async def generate_mind_map(self, request: MindMapGenerationRequest) -> None:
        """
        ÁîüÊàêÊµãËØïÁî®‰æãÊÄùÁª¥ÂØºÂõæ
        
        Args:
            request: ÊÄùÁª¥ÂØºÂõæÁîüÊàêËØ∑Ê±Ç
        """
        try:
            logger.info(f"ÂºÄÂßãÊÄùÁª¥ÂØºÂõæÁîüÊàêÂ∑•‰ΩúÊµÅ: {request.session_id}")
            
            # ÂàùÂßãÂåñËøêË°åÊó∂
            await self._initialize_runtime(request.session_id)
            
            # ÂèëÈÄÅÂà∞ÊÄùÁª¥ÂØºÂõæÁîüÊàêÊô∫ËÉΩ‰Ωì
            await self.runtime.publish_message(
                request,
                topic_id=TopicId(type=TopicTypes.MIND_MAP_GENERATOR.value, source="user")
            )
            
            logger.info(f"ÊÄùÁª¥ÂØºÂõæÁîüÊàêÂ∑•‰ΩúÊµÅÂêØÂä®ÂÆåÊàê: {request.session_id}")
            
        except Exception as e:
            logger.error(f"ÊÄùÁª¥ÂØºÂõæÁîüÊàêÂ∑•‰ΩúÊµÅÂ§±Ë¥•: {request.session_id}, ÈîôËØØ: {str(e)}")
            raise
        finally:
            await self._cleanup_runtime(request.session_id)

    async def export_to_excel(self, request: ExcelExportRequest) -> None:
        """
        ÂØºÂá∫ÊµãËØïÁî®‰æãÂà∞Excel
        
        Args:
            request: ExcelÂØºÂá∫ËØ∑Ê±Ç
        """
        try:
            logger.info(f"ÂºÄÂßãExcelÂØºÂá∫Â∑•‰ΩúÊµÅ: {request.session_id}")
            
            # ÂàùÂßãÂåñËøêË°åÊó∂
            await self._initialize_runtime(request.session_id)
            
            # ÂèëÈÄÅÂà∞ExcelÂØºÂá∫Êô∫ËÉΩ‰Ωì
            await self.runtime.publish_message(
                request,
                topic_id=TopicId(type=TopicTypes.EXCEL_EXPORTER.value, source="user")
            )
            
            logger.info(f"ExcelÂØºÂá∫Â∑•‰ΩúÊµÅÂêØÂä®ÂÆåÊàê: {request.session_id}")
            
        except Exception as e:
            logger.error(f"ExcelÂØºÂá∫Â∑•‰ΩúÊµÅÂ§±Ë¥•: {request.session_id}, ÈîôËØØ: {str(e)}")
            raise
        finally:
            await self._cleanup_runtime(request.session_id)

    async def batch_process(self, request: BatchProcessRequest) -> None:
        """
        ÊâπÈáèÂ§ÑÁêÜÂ§ö‰∏™Êñá‰ª∂
        
        Args:
            request: ÊâπÈáèÂ§ÑÁêÜËØ∑Ê±Ç
        """
        try:
            logger.info(f"ÂºÄÂßãÊâπÈáèÂ§ÑÁêÜÂ∑•‰ΩúÊµÅ: {request.session_id}")
            
            # ÂàùÂßãÂåñËøêË°åÊó∂
            await self._initialize_runtime(request.session_id)
            
            # Ê†πÊçÆÂ§ÑÁêÜÁ±ªÂûãÂàÜÂèëÂà∞‰∏çÂêåÁöÑÊô∫ËÉΩ‰Ωì
            for input_file in request.input_files:
                file_type = input_file.get("type")
                
                if file_type == "document":
                    # ÂàõÂª∫ÊñáÊ°£Ëß£ÊûêËØ∑Ê±Ç
                    doc_request = DocumentParseRequest(
                        session_id=f"{request.session_id}_{input_file['id']}",
                        file_name=input_file["name"],
                        file_path=input_file["path"],
                        document_type=input_file.get("document_type"),
                        analysis_target=request.process_config.get("analysis_target")
                    )
                    await self.parse_document(doc_request)
                    
                elif file_type == "image":
                    # ÂàõÂª∫ÂõæÁâáÂàÜÊûêËØ∑Ê±Ç
                    img_request = ImageAnalysisRequest(
                        session_id=f"{request.session_id}_{input_file['id']}",
                        image_name=input_file["name"],
                        image_path=input_file["path"],
                        image_type=input_file.get("image_type"),
                        analysis_target=request.process_config.get("analysis_target")
                    )
                    await self.analyze_image(img_request)
                    
                elif file_type == "api_spec":
                    # ÂàõÂª∫APIËßÑËåÉËß£ÊûêËØ∑Ê±Ç
                    api_request = ApiSpecParseRequest(
                        session_id=f"{request.session_id}_{input_file['id']}",
                        file_name=input_file["name"],
                        file_path=input_file["path"],
                        spec_type=input_file.get("spec_type"),
                        analysis_target=request.process_config.get("analysis_target")
                    )
                    await self.parse_api_spec(api_request)
            
            logger.info(f"ÊâπÈáèÂ§ÑÁêÜÂ∑•‰ΩúÊµÅÂêØÂä®ÂÆåÊàê: {request.session_id}")
            
        except Exception as e:
            logger.error(f"ÊâπÈáèÂ§ÑÁêÜÂ∑•‰ΩúÊµÅÂ§±Ë¥•: {request.session_id}, ÈîôËØØ: {str(e)}")
            raise

    def get_agent_factory_info(self) -> Dict[str, Any]:
        """
        Ëé∑ÂèñÊô∫ËÉΩ‰ΩìÂ∑•ÂéÇ‰ø°ÊÅØ
        
        Returns:
            Êô∫ËÉΩ‰ΩìÂ∑•ÂéÇÁöÑËØ¶ÁªÜ‰ø°ÊÅØ
        """
        return self.agent_factory.get_factory_info()

    def get_available_agents(self) -> List[str]:
        """
        Ëé∑ÂèñÂèØÁî®ÁöÑÊô∫ËÉΩ‰ΩìÂàóË°®
        
        Returns:
            ÂèØÁî®Êô∫ËÉΩ‰ΩìÁ±ªÂûãÂàóË°®
        """
        return self.agent_factory.get_available_agents()

    async def cleanup_session(self, session_id: str) -> None:
        """
        Ê∏ÖÁêÜ‰ºöËØùËµÑÊ∫ê

        Args:
            session_id: ‰ºöËØùÊ†áËØÜÁ¨¶
        """
        try:
            if session_id in self.active_sessions:
                del self.active_sessions[session_id]
                logger.info(f"‰ºöËØùËµÑÊ∫êÊ∏ÖÁêÜÂÆåÊàê: {session_id}")
        except Exception as e:
            logger.error(f"Ê∏ÖÁêÜ‰ºöËØùËµÑÊ∫êÂ§±Ë¥•: {session_id}, ÈîôËØØ: {str(e)}")

    # ==================== Á≥ªÁªüÁÆ°ÁêÜÊñπÊ≥ï ====================

    async def get_system_status(self) -> Dict[str, Any]:
        """Ëé∑ÂèñÁ≥ªÁªüÁä∂ÊÄÅ"""
        try:
            status = {
                "timestamp": datetime.now().isoformat(),
                "system_status": "healthy",
                "orchestrator_metrics": self.orchestrator_metrics.copy(),
                "active_sessions": list(self.active_sessions.keys())
            }

            # Êõ¥Êñ∞Ê¥ªË∑É‰ºöËØùÊï∞
            status["orchestrator_metrics"]["active_sessions"] = len(self.active_sessions)

            if self.use_agent_manager and self.agent_manager:
                # Ëé∑ÂèñÊô∫ËÉΩ‰ΩìÊÄßËÉΩÊåáÊ†á
                agent_metrics = await self.agent_manager.get_performance_metrics()
                health_status = await self.agent_manager.health_check()

                status.update({
                    "agent_metrics": agent_metrics,
                    "health_status": health_status,
                    "system_status": "healthy" if health_status["overall_status"] == "healthy" else "degraded"
                })
            else:
                # ‰º†ÁªüÊ®°ÂºèÁöÑÁä∂ÊÄÅ‰ø°ÊÅØ
                status.update({
                    "agent_metrics": {"mode": "traditional", "factory_info": self.get_agent_factory_info()},
                    "health_status": {"overall_status": "healthy", "mode": "traditional"}
                })

            return status

        except Exception as e:
            logger.error(f"Ëé∑ÂèñÁ≥ªÁªüÁä∂ÊÄÅÂ§±Ë¥•: {str(e)}")
            return {
                "timestamp": datetime.now().isoformat(),
                "system_status": "error",
                "error": str(e)
            }

    async def update_agent_config(self, agent_type: str, config_updates: Dict[str, Any]):
        """Êõ¥Êñ∞Êô∫ËÉΩ‰ΩìÈÖçÁΩÆ"""
        if not self.use_agent_manager or not self.agent_manager:
            raise RuntimeError("Êô∫ËÉΩ‰ΩìÁÆ°ÁêÜÂô®Ê®°ÂºèÊú™ÂêØÁî®ÊàñÊú™ÂàùÂßãÂåñ")

        await self.agent_manager.update_agent_config(agent_type, config_updates)
        logger.info(f"Â∑≤Êõ¥Êñ∞Êô∫ËÉΩ‰ΩìÈÖçÁΩÆ: {agent_type}")

    async def get_agent_list(self) -> List[Dict[str, Any]]:
        """Ëé∑ÂèñÊô∫ËÉΩ‰ΩìÂàóË°®"""
        if self.use_agent_manager and self.agent_manager:
            return self.agent_manager.get_agent_list()
        else:
            # ‰º†ÁªüÊ®°ÂºèËøîÂõûÂèØÁî®Êô∫ËÉΩ‰ΩìÂàóË°®
            available_agents = self.get_available_agents()
            return [
                {
                    "agent_type": agent_type,
                    "status": "active",
                    "mode": "traditional"
                }
                for agent_type in available_agents
            ]

    async def process_direct_requirement(self, request: DirectRequirementRequest) -> str:
        """Áõ¥Êé•ÈúÄÊ±ÇÂ§ÑÁêÜÂ∑•‰ΩúÊµÅ"""
        workflow_id = await self._start_workflow("direct_requirement", request.session_id)

        try:
            logger.info(f"ÂºÄÂßãÁõ¥Êé•ÈúÄÊ±ÇÂ§ÑÁêÜÂ∑•‰ΩúÊµÅ: {request.session_id}")

            # ÂàùÂßãÂåñËøêË°åÊó∂
            await self._initialize_runtime(request.session_id)

            # ÂèëÈÄÅÂà∞ÈúÄÊ±ÇÂàÜÊûêÊô∫ËÉΩ‰ΩìÔºå‰ΩøÁî®Êñ∞ÁöÑÊµãËØïÁÇπÊèêÂèñÊµÅÁ®ã
            requirement_analysis_request = RequirementAnalysisRequest(
                session_id=request.session_id,
                requirement_content=request.requirement_text,
                source_type="direct_requirement",
                source_data={
                    "requirement_text": request.requirement_text,
                    "requirement_title": getattr(request, 'requirement_title', None),
                    "analysis_target": getattr(request, 'analysis_target', 'ÁîüÊàêÊµãËØïÁî®‰æã'),
                    "input_method": "direct_workflow"
                },
                analysis_config={
                    "enable_detailed_analysis": True,
                    "extract_business_rules": True,
                    "identify_stakeholders": True,
                    "analyze_dependencies": True,
                    "auto_save": True,
                    "generate_mind_map": True
                }
            )

            await self.runtime.publish_message(
                requirement_analysis_request,
                topic_id=TopicId(type=TopicTypes.REQUIREMENT_ANALYZER.value, source="orchestrator")
            )

            await self._complete_workflow(workflow_id, True)
            logger.info(f"Áõ¥Êé•ÈúÄÊ±ÇÂ§ÑÁêÜÂ∑•‰ΩúÊµÅÂêØÂä®ÂÆåÊàê: {request.session_id}")
            return workflow_id

        except Exception as e:
            await self._complete_workflow(workflow_id, False, str(e))
            logger.error(f"Áõ¥Êé•ÈúÄÊ±ÇÂ§ÑÁêÜÂ∑•‰ΩúÊµÅÂ§±Ë¥•: {request.session_id}, ÈîôËØØ: {str(e)}")
            raise

    def get_agent_factory_info(self) -> Dict[str, Any]:
        """Ëé∑ÂèñÊô∫ËÉΩ‰ΩìÂ∑•ÂéÇ‰ø°ÊÅØÔºà‰º†ÁªüÊ®°ÂºèÔºâ"""
        available_types = self.agent_factory.get_available_agent_types()
        return {
            "available_agent_types": available_types,
            "registered_agents": len(self.agent_factory._registered_agents),
            "agent_classes": len(self.agent_factory._agent_classes),
            "total_available": len(available_types),
            "agent_categories": {
                "core": len([t for t in available_types if t in ["test_case_generator", "mind_map_generator", "test_case_saver"]]),
                "parser": len([t for t in available_types if t in ["document_parser", "image_analyzer", "api_spec_parser", "database_schema_parser", "video_analyzer"]]),
                "exporter": len([t for t in available_types if t == "excel_exporter"]),
                "web": len([t for t in available_types if any(prefix in t for prefix in ["page_", "yaml_", "playwright_"])])
            }
        }

    def get_available_agents(self) -> List[str]:
        """Ëé∑ÂèñÂèØÁî®ÁöÑÊô∫ËÉΩ‰ΩìÁ±ªÂûãÂàóË°®"""
        return self.agent_factory.get_available_agent_types()

    async def stop(self) -> None:
        """ÂÅúÊ≠¢ÁºñÊéíÂô®"""
        try:
            logger.info("üõë ÂÅúÊ≠¢ÊµãËØïÁî®‰æãÊô∫ËÉΩ‰ΩìÁºñÊéíÂô®...")

            if self.use_agent_manager and self.agent_manager:
                await self.agent_manager.shutdown()

            if self.runtime:
                await self.runtime.stop()
                self.runtime = None

            self.active_sessions.clear()
            logger.info("‚úÖ ÊµãËØïÁî®‰æãÊô∫ËÉΩ‰ΩìÁºñÊéíÂô®Â∑≤ÂÅúÊ≠¢")

        except Exception as e:
            logger.error(f"‚ùå ÂÅúÊ≠¢ÁºñÊéíÂô®Â§±Ë¥•: {str(e)}")


# ==================== ÂÖ®Â±ÄÂÆû‰æãÁÆ°ÁêÜ ====================

def get_test_case_orchestrator(collector: Optional[StreamResponseCollector] = None) -> TestCaseAgentOrchestrator:
    """
    Ëé∑ÂèñÊµãËØïÁî®‰æãÊô∫ËÉΩ‰ΩìÁºñÊéíÂô®ÂÆû‰æã
    
    Â∑•ÂéÇÂáΩÊï∞ÔºåÂàõÂª∫Êñ∞ÁöÑTestCaseAgentOrchestratorÂÆû‰æã„ÄÇ
    ÊØèÊ¨°Ë∞ÉÁî®ÈÉΩÂàõÂª∫Êñ∞ÂÆû‰æãÔºåÁ°Æ‰øùÊØè‰∏™Â∑•‰ΩúÊµÅÁöÑÁä∂ÊÄÅÂπ≤ÂáÄ„ÄÇ
    
    Args:
        collector: ÂèØÈÄâÁöÑStreamResponseCollectorÁî®‰∫éÊçïËé∑Êô∫ËÉΩ‰ΩìÂìçÂ∫î
    
    Returns:
        TestCaseAgentOrchestrator: ÂáÜÂ§áÂ•ΩËøõË°åÊô∫ËÉΩ‰ΩìÂ∑•‰ΩúÊµÅÁöÑÊñ∞ÁºñÊéíÂô®ÂÆû‰æã
    
    Ê≥®ÊÑè: Ê≠§ÂáΩÊï∞‰∏ç‰ºöËß¶Âèë‰ªª‰ΩïÊô∫ËÉΩ‰ΩìÊ∂àÊÅØÊµÅ„ÄÇ
    """
    return TestCaseAgentOrchestrator(collector)
