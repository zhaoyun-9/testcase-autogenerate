"""
APIËßÑËåÉËß£ÊûêÊô∫ËÉΩ‰Ωì
Ë¥üË¥£Ëß£ÊûêSwagger/OpenAPIËßÑËåÉÊñá‰ª∂ÔºåÁîüÊàêAPIÊµãËØïÁî®‰æã
"""
import uuid
import json
import yaml
from typing import Dict, List, Any, Optional
from datetime import datetime
from pathlib import Path

from autogen_core import message_handler, type_subscription, MessageContext, TopicId
from loguru import logger
from pydantic import BaseModel, Field

from app.core.agents.base import BaseAgent
from app.core.types import TopicTypes, AgentTypes, AGENT_NAMES
from app.core.messages.test_case import (
    ApiSpecParseRequest, ApiSpecParseResponse,
    TestCaseGenerationRequest, TestCaseData
)
from app.core.enums import TestType, TestLevel, Priority, InputSource


class ApiEndpoint(BaseModel):
    """APIÁ´ØÁÇπ‰ø°ÊÅØ"""
    path: str = Field(..., description="APIË∑ØÂæÑ")
    method: str = Field(..., description="HTTPÊñπÊ≥ï")
    summary: str = Field("", description="APIÊëòË¶Å")
    description: str = Field("", description="APIÊèèËø∞")
    parameters: List[Dict[str, Any]] = Field(default_factory=list, description="ÂèÇÊï∞ÂàóË°®")
    request_body: Optional[Dict[str, Any]] = Field(None, description="ËØ∑Ê±Ç‰Ωì")
    responses: Dict[str, Any] = Field(default_factory=dict, description="ÂìçÂ∫îÂÆö‰πâ")
    tags: List[str] = Field(default_factory=list, description="Ê†áÁ≠æ")
    security: List[Dict[str, Any]] = Field(default_factory=list, description="ÂÆâÂÖ®Ë¶ÅÊ±Ç")


class ApiSpecParseResult(BaseModel):
    """APIËßÑËåÉËß£ÊûêÁªìÊûú"""
    spec_version: str = Field("", description="ËßÑËåÉÁâàÊú¨")
    title: str = Field("", description="APIÊ†áÈ¢ò")
    version: str = Field("", description="APIÁâàÊú¨")
    description: str = Field("", description="APIÊèèËø∞")
    base_url: str = Field("", description="Âü∫Á°ÄURL")
    endpoints: List[ApiEndpoint] = Field(default_factory=list, description="APIÁ´ØÁÇπÂàóË°®")
    schemas: Dict[str, Any] = Field(default_factory=dict, description="Êï∞ÊçÆÊ®°Âûã")
    security_schemes: Dict[str, Any] = Field(default_factory=dict, description="ÂÆâÂÖ®ÊñπÊ°à")
    confidence_score: float = Field(0.0, description="Ëß£ÊûêÁΩÆ‰ø°Â∫¶")


@type_subscription(topic_type=TopicTypes.API_SPEC_PARSER.value)
class ApiSpecParserAgent(BaseAgent):
    """APIËßÑËåÉËß£ÊûêÊô∫ËÉΩ‰ΩìÔºåË¥üË¥£Ëß£ÊûêSwagger/OpenAPIËßÑËåÉÊñá‰ª∂"""

    def __init__(self, model_client_instance=None, **kwargs):
        """ÂàùÂßãÂåñAPIËßÑËåÉËß£ÊûêÊô∫ËÉΩ‰Ωì"""
        super().__init__(
            agent_id=AgentTypes.API_SPEC_PARSER.value,
            agent_name=AGENT_NAMES.get(AgentTypes.API_SPEC_PARSER.value, "APIËßÑËåÉËß£ÊûêÊô∫ËÉΩ‰Ωì"),
            model_client_instance=model_client_instance,
            **kwargs
        )
        
        # ÊîØÊåÅÁöÑËßÑËåÉÊ†ºÂºè
        self.supported_formats = {
            '.json': self._parse_json_spec,
            '.yaml': self._parse_yaml_spec,
            '.yml': self._parse_yaml_spec
        }
        
        logger.info(f"APIËßÑËåÉËß£ÊûêÊô∫ËÉΩ‰ΩìÂàùÂßãÂåñÂÆåÊàê: {self.agent_name}")

    @message_handler
    async def handle_api_spec_parse_request(
        self, 
        message: ApiSpecParseRequest, 
        ctx: MessageContext
    ) -> None:
        """Â§ÑÁêÜAPIËßÑËåÉËß£ÊûêËØ∑Ê±Ç"""
        try:
            logger.info(f"ÂºÄÂßãÂ§ÑÁêÜAPIËßÑËåÉËß£ÊûêËØ∑Ê±Ç: {message.session_id}")
            
            await self.send_response(
                f"üîç ÂºÄÂßãËß£ÊûêAPIËßÑËåÉ: {message.file_name}",
                region="process"
            )
            
            # Ëß£ÊûêAPIËßÑËåÉ
            parse_result = await self._parse_api_spec(message)
            
            # ÁîüÊàêÊµãËØïÁî®‰æã
            test_cases = await self._generate_test_cases_from_api_spec(
                parse_result, message
            )
            
            # ÊûÑÂª∫ÂìçÂ∫î
            response = ApiSpecParseResponse(
                session_id=message.session_id,
                spec_id=str(uuid.uuid4()),
                file_name=message.file_name,
                file_path=message.file_path,
                parse_result=parse_result.model_dump(),
                test_cases=test_cases,
                processing_time=0.0,
                created_at=datetime.now().isoformat()
            )
            
            await self.send_response(
                f"‚úÖ APIËßÑËåÉËß£ÊûêÂÆåÊàêÔºåÂèëÁé∞ {len(parse_result.endpoints)} ‰∏™Á´ØÁÇπ",
                is_final=True,
                result=response.model_dump()
            )
            
            # ÂèëÈÄÅÂà∞ÊµãËØïÁî®‰æãÁîüÊàêÊô∫ËÉΩ‰Ωì
            await self._send_to_test_case_generator(response)
            
        except Exception as e:
            logger.error(f"APIËßÑËåÉËß£ÊûêÂ§±Ë¥•: {str(e)}")
            await self.send_response(
                f"‚ùå APIËßÑËåÉËß£ÊûêÂ§±Ë¥•: {str(e)}",
                is_final=True,
                error=str(e)
            )

    async def _parse_api_spec(self, message: ApiSpecParseRequest) -> ApiSpecParseResult:
        """Ëß£ÊûêAPIËßÑËåÉÊñá‰ª∂"""
        try:
            file_path = Path(message.file_path)
            file_extension = file_path.suffix.lower()
            
            if file_extension not in self.supported_formats:
                raise ValueError(f"‰∏çÊîØÊåÅÁöÑAPIËßÑËåÉÊ†ºÂºè: {file_extension}")
            
            await self.send_response(f"üìñ Ê≠£Âú®Ëß£Êûê {file_extension} Ê†ºÂºèÁöÑAPIËßÑËåÉ...")
            
            # Ë∞ÉÁî®ÂØπÂ∫îÁöÑËß£ÊûêÊñπÊ≥ï
            parser_func = self.supported_formats[file_extension]
            spec_data = await parser_func(file_path)
            
            # Ëß£ÊûêËßÑËåÉÂÜÖÂÆπ
            parse_result = await self._analyze_api_spec_content(spec_data, message)
            
            return parse_result
            
        except Exception as e:
            logger.error(f"APIËßÑËåÉËß£ÊûêÂ§±Ë¥•: {str(e)}")
            raise

    async def _parse_json_spec(self, file_path: Path) -> Dict[str, Any]:
        """Ëß£ÊûêJSONÊ†ºÂºèÁöÑAPIËßÑËåÉ"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"JSONËßÑËåÉËß£ÊûêÂ§±Ë¥•: {str(e)}")
            raise

    async def _parse_yaml_spec(self, file_path: Path) -> Dict[str, Any]:
        """Ëß£ÊûêYAMLÊ†ºÂºèÁöÑAPIËßÑËåÉ"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return yaml.safe_load(f)
        except Exception as e:
            logger.error(f"YAMLËßÑËåÉËß£ÊûêÂ§±Ë¥•: {str(e)}")
            raise

    async def _analyze_api_spec_content(
        self, 
        spec_data: Dict[str, Any], 
        message: ApiSpecParseRequest
    ) -> ApiSpecParseResult:
        """ÂàÜÊûêAPIËßÑËåÉÂÜÖÂÆπ"""
        try:
            # Ê£ÄÊµãËßÑËåÉÁâàÊú¨
            spec_version = self._detect_spec_version(spec_data)
            
            await self.send_response(f"üìã Ê£ÄÊµãÂà∞ {spec_version} ËßÑËåÉ")
            
            # ÊèêÂèñÂü∫Êú¨‰ø°ÊÅØ
            info = spec_data.get('info', {})
            title = info.get('title', message.file_name)
            version = info.get('version', '1.0.0')
            description = info.get('description', '')
            
            # ÊèêÂèñÊúçÂä°Âô®‰ø°ÊÅØ
            base_url = self._extract_base_url(spec_data)
            
            # Ëß£ÊûêAPIÁ´ØÁÇπ
            endpoints = await self._parse_endpoints(spec_data, spec_version)
            
            await self.send_response(f"üîó Ëß£ÊûêÂà∞ {len(endpoints)} ‰∏™APIÁ´ØÁÇπ")
            
            # ÊèêÂèñÊï∞ÊçÆÊ®°Âûã
            schemas = self._extract_schemas(spec_data, spec_version)
            
            # ÊèêÂèñÂÆâÂÖ®ÊñπÊ°à
            security_schemes = self._extract_security_schemes(spec_data, spec_version)
            
            return ApiSpecParseResult(
                spec_version=spec_version,
                title=title,
                version=version,
                description=description,
                base_url=base_url,
                endpoints=endpoints,
                schemas=schemas,
                security_schemes=security_schemes,
                confidence_score=0.9
            )
            
        except Exception as e:
            logger.error(f"APIËßÑËåÉÂÜÖÂÆπÂàÜÊûêÂ§±Ë¥•: {str(e)}")
            raise

    def _detect_spec_version(self, spec_data: Dict[str, Any]) -> str:
        """Ê£ÄÊµãAPIËßÑËåÉÁâàÊú¨"""
        if 'openapi' in spec_data:
            return f"OpenAPI {spec_data['openapi']}"
        elif 'swagger' in spec_data:
            return f"Swagger {spec_data['swagger']}"
        else:
            return "Unknown"

    def _extract_base_url(self, spec_data: Dict[str, Any]) -> str:
        """ÊèêÂèñÂü∫Á°ÄURL"""
        # OpenAPI 3.x
        if 'servers' in spec_data and spec_data['servers']:
            return spec_data['servers'][0].get('url', '')
        
        # Swagger 2.x
        if 'host' in spec_data:
            scheme = spec_data.get('schemes', ['http'])[0]
            host = spec_data['host']
            base_path = spec_data.get('basePath', '')
            return f"{scheme}://{host}{base_path}"
        
        return ""

    async def _parse_endpoints(
        self, 
        spec_data: Dict[str, Any], 
        spec_version: str
    ) -> List[ApiEndpoint]:
        """Ëß£ÊûêAPIÁ´ØÁÇπ"""
        try:
            endpoints = []
            paths = spec_data.get('paths', {})
            
            for path, path_item in paths.items():
                for method, operation in path_item.items():
                    if method.lower() in ['get', 'post', 'put', 'delete', 'patch', 'head', 'options']:
                        endpoint = ApiEndpoint(
                            path=path,
                            method=method.upper(),
                            summary=operation.get('summary', ''),
                            description=operation.get('description', ''),
                            parameters=operation.get('parameters', []),
                            request_body=operation.get('requestBody'),
                            responses=operation.get('responses', {}),
                            tags=operation.get('tags', []),
                            security=operation.get('security', [])
                        )
                        endpoints.append(endpoint)
            
            return endpoints
            
        except Exception as e:
            logger.error(f"Ëß£ÊûêAPIÁ´ØÁÇπÂ§±Ë¥•: {str(e)}")
            return []

    def _extract_schemas(self, spec_data: Dict[str, Any], spec_version: str) -> Dict[str, Any]:
        """ÊèêÂèñÊï∞ÊçÆÊ®°Âûã"""
        try:
            # OpenAPI 3.x
            if 'components' in spec_data and 'schemas' in spec_data['components']:
                return spec_data['components']['schemas']
            
            # Swagger 2.x
            if 'definitions' in spec_data:
                return spec_data['definitions']
            
            return {}
            
        except Exception as e:
            logger.error(f"ÊèêÂèñÊï∞ÊçÆÊ®°ÂûãÂ§±Ë¥•: {str(e)}")
            return {}

    def _extract_security_schemes(self, spec_data: Dict[str, Any], spec_version: str) -> Dict[str, Any]:
        """ÊèêÂèñÂÆâÂÖ®ÊñπÊ°à"""
        try:
            # OpenAPI 3.x
            if 'components' in spec_data and 'securitySchemes' in spec_data['components']:
                return spec_data['components']['securitySchemes']
            
            # Swagger 2.x
            if 'securityDefinitions' in spec_data:
                return spec_data['securityDefinitions']
            
            return {}
            
        except Exception as e:
            logger.error(f"ÊèêÂèñÂÆâÂÖ®ÊñπÊ°àÂ§±Ë¥•: {str(e)}")
            return {}

    async def _generate_test_cases_from_api_spec(
        self, 
        parse_result: ApiSpecParseResult,
        message: ApiSpecParseRequest
    ) -> List[TestCaseData]:
        """‰ªéAPIËßÑËåÉÁîüÊàêÊµãËØïÁî®‰æã"""
        test_cases = []
        
        try:
            # ‰∏∫ÊØè‰∏™APIÁ´ØÁÇπÁîüÊàêÊµãËØïÁî®‰æã
            for endpoint in parse_result.endpoints:
                # Âü∫Á°ÄÂäüËÉΩÊµãËØïÁî®‰æã
                basic_test_case = TestCaseData(
                    title=f"ÊµãËØï {endpoint.method} {endpoint.path}",
                    description=f"ÊµãËØïAPIÁ´ØÁÇπ: {endpoint.summary or endpoint.description}",
                    test_type=TestType.INTERFACE,
                    test_level=TestLevel.INTEGRATION,
                    priority=self._determine_api_priority(endpoint),
                    input_source=InputSource.API_SPEC,
                    source_metadata={
                        "api_spec": message.file_name,
                        "endpoint_path": endpoint.path,
                        "endpoint_method": endpoint.method,
                        "endpoint_tags": endpoint.tags
                    },
                    ai_confidence=parse_result.confidence_score
                )
                test_cases.append(basic_test_case)
                
                # ÂèÇÊï∞È™åËØÅÊµãËØïÁî®‰æã
                if endpoint.parameters:
                    param_test_case = TestCaseData(
                        title=f"ÊµãËØï {endpoint.method} {endpoint.path} ÂèÇÊï∞È™åËØÅ",
                        description=f"ÊµãËØïAPIÂèÇÊï∞È™åËØÅÈÄªËæë",
                        test_type=TestType.INTERFACE,
                        test_level=TestLevel.INTEGRATION,
                        priority=Priority.P2,
                        input_source=InputSource.API_SPEC,
                        source_metadata={
                            "api_spec": message.file_name,
                            "endpoint_path": endpoint.path,
                            "endpoint_method": endpoint.method,
                            "test_focus": "parameter_validation"
                        },
                        ai_confidence=parse_result.confidence_score
                    )
                    test_cases.append(param_test_case)
                
                # ÈîôËØØÂ§ÑÁêÜÊµãËØïÁî®‰æã
                error_test_case = TestCaseData(
                    title=f"ÊµãËØï {endpoint.method} {endpoint.path} ÈîôËØØÂ§ÑÁêÜ",
                    description=f"ÊµãËØïAPIÈîôËØØÂìçÂ∫îÂ§ÑÁêÜ",
                    test_type=TestType.INTERFACE,
                    test_level=TestLevel.INTEGRATION,
                    priority=Priority.P2,
                    input_source=InputSource.API_SPEC,
                    source_metadata={
                        "api_spec": message.file_name,
                        "endpoint_path": endpoint.path,
                        "endpoint_method": endpoint.method,
                        "test_focus": "error_handling"
                    },
                    ai_confidence=parse_result.confidence_score
                )
                test_cases.append(error_test_case)
                
                # ÂÆâÂÖ®ÊµãËØïÁî®‰æãÔºàÂ¶ÇÊûúÊúâÂÆâÂÖ®Ë¶ÅÊ±ÇÔºâ
                if endpoint.security:
                    security_test_case = TestCaseData(
                        title=f"ÊµãËØï {endpoint.method} {endpoint.path} ÂÆâÂÖ®ËÆ§ËØÅ",
                        description=f"ÊµãËØïAPIÂÆâÂÖ®ËÆ§ËØÅÊú∫Âà∂",
                        test_type=TestType.SECURITY,
                        test_level=TestLevel.INTEGRATION,
                        priority=Priority.P1,
                        input_source=InputSource.API_SPEC,
                        source_metadata={
                            "api_spec": message.file_name,
                            "endpoint_path": endpoint.path,
                            "endpoint_method": endpoint.method,
                            "test_focus": "security"
                        },
                        ai_confidence=parse_result.confidence_score
                    )
                    test_cases.append(security_test_case)
            
            # ÁîüÊàêÊÄßËÉΩÊµãËØïÁî®‰æã
            if len(parse_result.endpoints) > 0:
                performance_test_case = TestCaseData(
                    title=f"APIÊÄßËÉΩÊµãËØï - {parse_result.title}",
                    description="ÊµãËØïAPIÊï¥‰ΩìÊÄßËÉΩË°®Áé∞",
                    test_type=TestType.PERFORMANCE,
                    test_level=TestLevel.SYSTEM,
                    priority=Priority.P2,
                    input_source=InputSource.API_SPEC,
                    source_metadata={
                        "api_spec": message.file_name,
                        "test_focus": "performance",
                        "endpoints_count": len(parse_result.endpoints)
                    },
                    ai_confidence=parse_result.confidence_score
                )
                test_cases.append(performance_test_case)
            
            logger.info(f"‰ªéAPIËßÑËåÉÁîüÊàê‰∫Ü {len(test_cases)} ‰∏™ÊµãËØïÁî®‰æã")
            return test_cases
            
        except Exception as e:
            logger.error(f"ÁîüÊàêÊµãËØïÁî®‰æãÂ§±Ë¥•: {str(e)}")
            return []

    def _determine_api_priority(self, endpoint: ApiEndpoint) -> Priority:
        """Á°ÆÂÆöAPIÊµãËØï‰ºòÂÖàÁ∫ß"""
        # Ê†πÊçÆHTTPÊñπÊ≥ïÁ°ÆÂÆö‰ºòÂÖàÁ∫ß
        method_priority = {
            'POST': Priority.P1,    # ÂàõÂª∫Êìç‰ΩúÔºåÈ´ò‰ºòÂÖàÁ∫ß
            'PUT': Priority.P1,     # Êõ¥Êñ∞Êìç‰ΩúÔºåÈ´ò‰ºòÂÖàÁ∫ß
            'DELETE': Priority.P1,  # Âà†Èô§Êìç‰ΩúÔºåÈ´ò‰ºòÂÖàÁ∫ß
            'GET': Priority.P2,     # Êü•ËØ¢Êìç‰ΩúÔºå‰∏≠‰ºòÂÖàÁ∫ß
            'PATCH': Priority.P2,   # ÈÉ®ÂàÜÊõ¥Êñ∞Ôºå‰∏≠‰ºòÂÖàÁ∫ß
            'HEAD': Priority.P3,    # Â§¥ÈÉ®‰ø°ÊÅØÔºå‰Ωé‰ºòÂÖàÁ∫ß
            'OPTIONS': Priority.P3  # ÈÄâÈ°π‰ø°ÊÅØÔºå‰Ωé‰ºòÂÖàÁ∫ß
        }
        
        # Ê†πÊçÆÊ†áÁ≠æË∞ÉÊï¥‰ºòÂÖàÁ∫ß
        if any(tag.lower() in ['auth', 'login', 'security'] for tag in endpoint.tags):
            return Priority.P0  # ÂÆâÂÖ®Áõ∏ÂÖ≥ÔºåÊúÄÈ´ò‰ºòÂÖàÁ∫ß
        
        return method_priority.get(endpoint.method, Priority.P2)

    async def _send_to_test_case_generator(self, response: ApiSpecParseResponse):
        """ÂèëÈÄÅÂà∞ÊµãËØïÁî®‰æãÁîüÊàêÊô∫ËÉΩ‰Ωì"""
        try:
            generation_request = TestCaseGenerationRequest(
                session_id=response.session_id,
                source_type="api_spec",
                source_data=response.model_dump(),
                test_cases=response.test_cases,
                generation_config={
                    "auto_save": True,
                    "generate_mind_map": True
                }
            )
            
            await self.publish_message(
                generation_request,
                topic_id=TopicId(type=TopicTypes.TEST_CASE_GENERATOR.value, source=self.id.key)
            )
            
            logger.info(f"Â∑≤ÂèëÈÄÅÂà∞ÊµãËØïÁî®‰æãÁîüÊàêÊô∫ËÉΩ‰Ωì: {response.session_id}")
            
        except Exception as e:
            logger.error(f"ÂèëÈÄÅÂà∞ÊµãËØïÁî®‰æãÁîüÊàêÊô∫ËÉΩ‰ΩìÂ§±Ë¥•: {str(e)}")
